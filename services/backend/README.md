# Demo Backend

Сервис для демонстрации подходов и интеграций в разработке приложений.

## Референсы

- [12 factor app](https://12factor.net/ru/)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Microservice Architecture](https://microservices.io/)

## Домен

- Модель - набор свойств и методов для определенной сущности, может включать вложенные модели. Изолирует ключевую логику, проверки и преобразования для повторного использования в приложении;
- Схема - описание структуры данных для передачи в транспортный слой;
- Сущность - набор атрибутов во внешнем источнике данных (часто база данных);
- Моки - фабрики сущностей для создания unit-тестов.

## Архитектура

1. Решение основано на базе Clean Architecture и DDD для реализации модульного монолита;
1. Каждый обработчик реализован в виде отдельного модуля для описания use-case;
1. Модуль для use-case должен быть разделен на слои (описание см. раздел Слои);
1. В каждом слое не допускается использование структур другого слоя или модуля напрямую;
1. Обязательно наличие unit-тестов в каждом модуле с минимальным набором кейсов;
1. Каждый use-case должен стремиться к максимальной изоляции;
1. Каждый модуль должен использовать только DI-провайдеры, поэтому не допускается использование функций без Injectable классов;
1. Не допускается чрезмерное ветвление логики внутри одного use-case — при необходимости его следует разделить на несколько;
1. Не допускаются критичные изменения в структурах ответов, которые нарушают обратную совместимость;
1. Категорически не допускается продолжительное хранение данных в памяти приложение;
1. Любые константы считаются настройками и должны храниться со всеми настройками вместе;
1. Обязательно перехватывать все ошибки и возвращать только публичную информацию, при этом писать в логи больше подробностей;
1. Все настройки приложения должны описываться в переменных окружения;
1. Не допускается использовать utils функции вне контекста моделей;
1. Запрещено использовать приватные методы классов.

### Слои

#### Integration
Отвечает за получение данных из внешних источников (базы данных, внешние API) и изолирует особенности взаимодействия с каждой интеграцией. Не допускается описание бизнес-логики, всегда возвращает экземпляр модели.

#### Transport
Занимается обработкой входящих запросов различных протоколов (REST API, GraphQL, RPC) и изолирует особенности описания каждого протокола. Выполняет преобразование модели в схему ответа. Не допускается наличие блоков бизнес-логики.

#### Business
Содержит ключевую логику приложения и связывает все слои между собой. Должен быть абстрагирован от особенностей и структур данных на слоях интеграций и транспорта.

## Базы данных

1. Основная БД всегда Postgres;
1. Для взаимодействия с базой всегда используется TypeORM;
1. Не допускается использование одной базы данных несколькими сервисами, поэтому сервис должен иметь эксклюзивный доступ к своей базе данных;
1. Не допускается автоматическое управление схемой или содержимым базы данных, все изменения должны выполняться вручную;
1. Любые изменения схемы должны быть обратно совместимыми с прошлой версией;
1. Актуальные схемы таблиц должны храниться в проекте в SQL файле.

## Деплой

1. Приложение должно запускаться быстро без каких-либо предварительных синхронизаций;
1. Не допускается использование таймеров и cron;
1. Сервис должен следовать принципам Graceful Shutdown и отключаться от всех внешних интеграций при плановой остановке;
1. Обязательно наличие healthcheck, которое включает проверку всех интеграций;
1. Для доставки сервисов всегда используется Docker-образы.

## Инструменты

1. Обязательно использование NestJS, а также его подходов и техник на основе официальной документации;
1. Обязательно использование TypeScript и ESLint;
1. Для E2E тестирования обязательно использовать testcontainers;

## FAQ

#### В чем отличие модели и сущности?
Сущность отражает содержимое БД, по сути - это DTO. В некоторых случаях, DTO может быть расширено валидацией. Модель - это представление данных с точки зрения бизнеса и может содержать вспомогательные методы. Такой подход позволяет разделить ответственность и инкапсулировать бизнес-логику.

#### Как должна выглядеть модель?
Обычно, модель хранит все свойства и методы, которые необходимы для взаимодействия с ней. В базовом варианте модель содержит метод инициализации и преобразования в какую-либо итоговую структуру. В расширенном варианте модель может содержать методы для проверки консистентности или преобразования данных, а также дочерние модели или агрегаты.

#### Почему нельзя в ответы на запрос возвращать сущности?
Очень часто у базы данных есть свои требования не работы с данными. Поэтому необходимо разделять это структуры, чтобы мы могли отдельно планировать работу с данными и отдельно формировать ответы на запрос. У каждой части системы должна быть одна и единственная причина для изменения (S из SOLID).

#### Почему каждый запрос надо выделять в отдельный модуль?
Такой подход позволяет изолировать контекст между блоками логики для более гибкой поддержки и развития. Таким образом, мы можем вносить изменения без рисков для других частей приложения. Также важно помнить, что схожие части приложения не всегда являются одинаковыми и в будущем число отличий может вырасти. Удобство тестирования является дополнительным преимуществом.

#### Зачем нужно разбивать модуль на слои?
В первую очередь, такой подход позволяет разделить ответственность. Особенно это важно для бизнес логики, на уровне которой нам совершенно безразлично как хранятся данные или каким протоколом они передаются.

#### Как снижать связность между модулями и use-case?
Необходимо избегать прямых @Inject между модулями. Общая логика должна содержаться на некотором глобальном уровне (например, модель или репозиторий). Также допускается использование шины событий внутри сервиса на базе EventEmitter2, которые поддерживают асинхронные функции.

#### Как инвертировать зависимости?
Самый простой сценарий - это всегда использовать интерфейсы вместе конкретных классов. Например, в бизнес слое не допускается использовать конкретные реализации DTO-запросов, поэтому такую зависимость мы можем развязать интерфейсом.

#### Как переиспользовать типы или методы?
В рамках модуля необходимо снижать связность, но для упрощения разработки можно использовать некоторые подходы:
- Типы и интерфейсы можно переиспользовать через промежуточный тип, что позволит заменить связанный тип на собственную реализацию при необходимости;
- В рамках слоя integration допускает связь с любыми сторонними модулями, что позволяет гибко изменять структуру зависимостей без затрагивания бизнес-логики.

#### Чем заменить приватные методы?
Обычно в приватный метод выделяют какую-либо часть общей бизнес-логики, но такой подход может осложнять чтение и поддержку кода. Класс может стать слишком большим, поэтому лучше сразу выделять общую логику в отдельный класс на уровне текущего слоя.

#### Зачем нужны unit-тесты?
Создание тестов позволяет оптимизировать разработку нового функционала за счет автоматизации рутинных действий. Обычно для разработки необходимо запущенная БД с данными, данные для авторизации, формирование запроса и проверка ответов. Модульная архитектура сильно упрощает создание тестов, поэтому за счет unit тесты открывается возможность не запускать ни базу, ни сам сервис, а только необходимый модуль. Весь процесс описан в коде и может воспроизводиться одной командой без лишних усилий. Более сложное тестирование актуальнее проводить с применением E2E подходов

#### Как реализовать поддержку прошлой версии?
Любые изменения структуры в `response` или схемах базы данных должны носить характер дополнений. Например, при смене типа колонки в БД необходимо создать новую колонку и записывать одно значение в две колонки. Впоследствии, старую колонку можно и удалить, но только после уверенности в полном отказе от старой колонки.

#### Почему нельзя использовать функции без класса?
Технически это возможно, но нарушает многие принятые подходы. В NestJS мы пользуемся модулями для управления зависимостями. Такой подход позволяет точнее управлять границами контекста, а также облегчает создание тестов.

#### Что использовать взамен utils?
Обычно, такие утилиты нужны для бизнес задач, которые более уместно использовать в рамках моделей.

#### Почему нельзя писать миграции?
Это нарушает принципы при запуске приложение, создает риски промежуточного нарушенного состояния БД, возникают ограничения при репликации и бесшовном релизе.

#### Как изменить схему в БД?
Допускается реализация утилит для управления базой данных, но это всегда отдельный модуль и с отдельной точкой входа. Стоит обратить внимание на существующий [модуль на базе Umzug](https://github.com/quazex/nestjs-umzug), которые описывает решение подобной задачи.

#### Почему нельзя использовать cron в сервисах?
Причины похожи на причины отказа от автозапуска миграций: сложно реплицировать, деплоить и контролировать из приложения. В рамках приложения можно создавать сам обработчик, но запуск должен происходить внешними инструментами (например, через [render](https://render.com/docs/cronjobs)).

#### Как реализовать кэширование?
Использовать любое внешнее хранилище:
- Redis если нужно инвалидировать по таймеру;
- Mongodb для сложных кейсов и более долгого хранения;
- S3 тоже неплохой вариант, но следует использовать осторожно.
